//! Graphics Subsystem
//!
//! Framebuffer and graphics rendering for WebbOS.

use alloc::vec::Vec;
use alloc::vec;
use alloc::boxed::Box;
use spin::Mutex;
use lazy_static::lazy_static;

use crate::println;

/// Framebuffer info
#[derive(Debug, Clone, Copy)]
pub struct FramebufferInfo {
    pub width: u32,
    pub height: u32,
    pub pitch: u32,
    pub bpp: u8,
    pub red_mask: u32,
    pub green_mask: u32,
    pub blue_mask: u32,
}

/// Framebuffer structure
pub struct Framebuffer {
    info: FramebufferInfo,
    buffer: *mut u8,
    size: usize,
}

/// Graphics context for drawing
pub struct GraphicsContext {
    width: u32,
    height: u32,
    pixels: Vec<u32>,
}

impl GraphicsContext {
    /// Create new graphics context
    pub fn new(width: u32, height: u32) -> Self {
        Self {
            width,
            height,
            pixels: vec![0; (width * height) as usize],
        }
    }
    
    /// Get width
    pub fn width(&self) -> u32 {
        self.width
    }
    
    /// Get height
    pub fn height(&self) -> u32 {
        self.height
    }
    
    /// Clear with color
    pub fn clear(&mut self, color: u32) {
        self.pixels.fill(color);
    }
    
    /// Set pixel
    pub fn set_pixel(&mut self, x: u32, y: u32, color: u32) {
        if x < self.width && y < self.height {
            self.pixels[(y * self.width + x) as usize] = color;
        }
    }
    
    /// Get pixel
    pub fn get_pixel(&self, x: u32, y: u32) -> u32 {
        if x < self.width && y < self.height {
            self.pixels[(y * self.width + x) as usize]
        } else {
            0
        }
    }
    
    /// Draw filled rectangle
    pub fn fill_rect(&mut self, x: i32, y: i32, w: u32, h: u32, color: u32) {
        for dy in 0..h as i32 {
            for dx in 0..w as i32 {
                self.set_pixel((x + dx) as u32, (y + dy) as u32, color);
            }
        }
    }
    
    /// Draw rectangle outline
    pub fn draw_rect(&mut self, x: i32, y: i32, w: u32, h: u32, color: u32) {
        for dx in 0..w as i32 {
            self.set_pixel((x + dx) as u32, y as u32, color);
            self.set_pixel((x + dx) as u32, (y + h as i32 - 1) as u32, color);
        }
        for dy in 0..h as i32 {
            self.set_pixel(x as u32, (y + dy) as u32, color);
            self.set_pixel((x + w as i32 - 1) as u32, (y + dy) as u32, color);
        }
    }
    
    /// Draw line (Bresenham)
    pub fn draw_line(&mut self, x0: i32, y0: i32, x1: i32, y1: i32, color: u32) {
        let dx = (x1 - x0).abs();
        let dy = (y1 - y0).abs();
        let sx = if x0 < x1 { 1 } else { -1 };
        let sy = if y0 < y1 { 1 } else { -1 };
        let mut err = dx - dy;
        let mut x = x0;
        let mut y = y0;

        loop {
            self.set_pixel(x as u32, y as u32, color);
            
            if x == x1 && y == y1 {
                break;
            }
            
            let e2 = 2 * err;
            if e2 > -dy {
                err -= dy;
                x += sx;
            }
            if e2 < dx {
                err += dx;
                y += sy;
            }
        }
    }
    
    /// Draw circle (Bresenham)
    pub fn draw_circle(&mut self, cx: i32, cy: i32, radius: i32, color: u32) {
        let mut x = radius;
        let mut y = 0;
        let mut err = 0;

        while x >= y {
            self.set_pixel((cx + x) as u32, (cy + y) as u32, color);
            self.set_pixel((cx + y) as u32, (cy + x) as u32, color);
            self.set_pixel((cx - y) as u32, (cy + x) as u32, color);
            self.set_pixel((cx - x) as u32, (cy + y) as u32, color);
            self.set_pixel((cx - x) as u32, (cy - y) as u32, color);
            self.set_pixel((cx - y) as u32, (cy - x) as u32, color);
            self.set_pixel((cx + y) as u32, (cy - x) as u32, color);
            self.set_pixel((cx + x) as u32, (cy - y) as u32, color);

            y += 1;
            err += 1 + 2 * y;
            if 2 * (err - x) + 1 > 0 {
                x -= 1;
                err += 1 - 2 * x;
            }
        }
    }
    
    /// Fill circle (using integer sqrt)
    pub fn fill_circle(&mut self, cx: i32, cy: i32, radius: i32, color: u32) {
        for dy in -radius..=radius {
            let dx = integer_sqrt(radius * radius - dy * dy);
            self.draw_line(cx - dx, cy + dy, cx + dx, cy + dy, color);
        }
    }
    
    /// Blit another graphics context onto this one
    pub fn blit(&mut self, src: &GraphicsContext, x: i32, y: i32) {
        for sy in 0..src.height {
            for sx in 0..src.width {
                let color = src.get_pixel(sx, sy);
                self.set_pixel((x + sx as i32) as u32, (y + sy as i32) as u32, color);
            }
        }
    }
    
    /// Draw text (using bitmap font)
    pub fn draw_text(&mut self, text: &str, x: i32, y: i32, color: u32, scale: u32) {
        let mut cx = x;
        for ch in text.chars() {
            self.draw_char(ch, cx, y, color, scale);
            cx += (8 * scale) as i32;
        }
    }
    
    /// Draw single character
    fn draw_char(&mut self, ch: char, x: i32, y: i32, color: u32, scale: u32) {
        let bitmap = get_char_bitmap(ch);
        for row in 0..8usize {
            for col in 0..8usize {
                if bitmap[row] & (1 << (7 - col)) != 0 {
                    for sy in 0..scale {
                        for sx in 0..scale {
                            self.set_pixel(
                                (x + (col * scale as usize + sx as usize) as i32) as u32,
                                (y + (row * scale as usize + sy as usize) as i32) as u32,
                                color
                            );
                        }
                    }
                }
            }
        }
    }
    
    /// Get raw pixel buffer
    pub fn pixels(&self) -> &[u32] {
        &self.pixels
    }
    
    /// Get mutable pixel buffer
    pub fn pixels_mut(&mut self) -> &mut [u32] {
        &mut self.pixels
    }
}

/// Get 8x8 bitmap for character
fn get_char_bitmap(ch: char) -> [u8; 8] {
    // Simple 8x8 font bitmaps for common characters
    match ch {
        ' ' => [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        '!' => [0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x00],
        '"' => [0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00],
        '#' => [0x66, 0x66, 0xff, 0x66, 0xff, 0x66, 0x66, 0x00],
        '$' => [0x18, 0x3e, 0x60, 0x3c, 0x06, 0x7c, 0x18, 0x00],
        '%' => [0x62, 0x66, 0x0c, 0x18, 0x30, 0x66, 0x46, 0x00],
        '&' => [0x3c, 0x66, 0x3c, 0x38, 0x67, 0x66, 0x3f, 0x00],
        '\'' => [0x06, 0x0c, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00],
        '(' => [0x0c, 0x18, 0x30, 0x30, 0x30, 0x18, 0x0c, 0x00],
        ')' => [0x30, 0x18, 0x0c, 0x0c, 0x0c, 0x18, 0x30, 0x00],
        '*' => [0x00, 0x66, 0x3c, 0xff, 0x3c, 0x66, 0x00, 0x00],
        '+' => [0x00, 0x18, 0x18, 0x7e, 0x18, 0x18, 0x00, 0x00],
        ',' => [0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30],
        '-' => [0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00],
        '.' => [0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00],
        '/' => [0x00, 0x03, 0x06, 0x0c, 0x18, 0x30, 0x60, 0x00],
        '0' => [0x3c, 0x66, 0x6e, 0x76, 0x66, 0x66, 0x3c, 0x00],
        '1' => [0x18, 0x18, 0x38, 0x18, 0x18, 0x18, 0x7e, 0x00],
        '2' => [0x3c, 0x66, 0x06, 0x0c, 0x30, 0x60, 0x7e, 0x00],
        '3' => [0x3c, 0x66, 0x06, 0x1c, 0x06, 0x66, 0x3c, 0x00],
        '4' => [0x06, 0x0e, 0x1e, 0x66, 0x7f, 0x06, 0x06, 0x00],
        '5' => [0x7e, 0x60, 0x7c, 0x06, 0x06, 0x66, 0x3c, 0x00],
        '6' => [0x3c, 0x66, 0x60, 0x7c, 0x66, 0x66, 0x3c, 0x00],
        '7' => [0x7e, 0x66, 0x0c, 0x18, 0x18, 0x18, 0x18, 0x00],
        '8' => [0x3c, 0x66, 0x66, 0x3c, 0x66, 0x66, 0x3c, 0x00],
        '9' => [0x3c, 0x66, 0x66, 0x3e, 0x06, 0x66, 0x3c, 0x00],
        ':' => [0x00, 0x00, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00],
        ';' => [0x00, 0x00, 0x18, 0x00, 0x00, 0x18, 0x18, 0x30],
        '<' => [0x0e, 0x18, 0x30, 0x60, 0x30, 0x18, 0x0e, 0x00],
        '=' => [0x00, 0x00, 0x7e, 0x00, 0x7e, 0x00, 0x00, 0x00],
        '>' => [0x70, 0x18, 0x0c, 0x06, 0x0c, 0x18, 0x70, 0x00],
        '?' => [0x3c, 0x66, 0x06, 0x0c, 0x18, 0x00, 0x18, 0x00],
        '@' => [0x3c, 0x66, 0x6e, 0x6e, 0x60, 0x62, 0x3c, 0x00],
        'A' => [0x18, 0x3c, 0x66, 0x7e, 0x66, 0x66, 0x66, 0x00],
        'B' => [0x7c, 0x66, 0x66, 0x7c, 0x66, 0x66, 0x7c, 0x00],
        'C' => [0x3c, 0x66, 0x60, 0x60, 0x60, 0x66, 0x3c, 0x00],
        'D' => [0x78, 0x6c, 0x66, 0x66, 0x66, 0x6c, 0x78, 0x00],
        'E' => [0x7e, 0x60, 0x60, 0x78, 0x60, 0x60, 0x7e, 0x00],
        'F' => [0x7e, 0x60, 0x60, 0x78, 0x60, 0x60, 0x60, 0x00],
        'G' => [0x3c, 0x66, 0x60, 0x6e, 0x66, 0x66, 0x3c, 0x00],
        'H' => [0x66, 0x66, 0x66, 0x7e, 0x66, 0x66, 0x66, 0x00],
        'I' => [0x3c, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x00],
        'J' => [0x1e, 0x0c, 0x0c, 0x0c, 0x0c, 0x6c, 0x38, 0x00],
        'K' => [0x66, 0x6c, 0x78, 0x70, 0x78, 0x6c, 0x66, 0x00],
        'L' => [0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x7e, 0x00],
        'M' => [0x63, 0x77, 0x7f, 0x6b, 0x63, 0x63, 0x63, 0x00],
        'N' => [0x66, 0x76, 0x7e, 0x7e, 0x6e, 0x66, 0x66, 0x00],
        'O' => [0x3c, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3c, 0x00],
        'P' => [0x7c, 0x66, 0x66, 0x7c, 0x60, 0x60, 0x60, 0x00],
        'Q' => [0x3c, 0x66, 0x66, 0x66, 0x66, 0x3c, 0x0e, 0x00],
        'R' => [0x7c, 0x66, 0x66, 0x7c, 0x78, 0x6c, 0x66, 0x00],
        'S' => [0x3c, 0x66, 0x60, 0x3c, 0x06, 0x66, 0x3c, 0x00],
        'T' => [0x7e, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00],
        'U' => [0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3c, 0x00],
        'V' => [0x66, 0x66, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x00],
        'W' => [0x63, 0x63, 0x63, 0x6b, 0x7f, 0x77, 0x63, 0x00],
        'X' => [0x66, 0x66, 0x3c, 0x18, 0x3c, 0x66, 0x66, 0x00],
        'Y' => [0x66, 0x66, 0x66, 0x3c, 0x18, 0x18, 0x18, 0x00],
        'Z' => [0x7e, 0x06, 0x0c, 0x18, 0x30, 0x60, 0x7e, 0x00],
        '[' => [0x3c, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3c, 0x00],
        '\\' => [0x00, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x03, 0x00],
        ']' => [0x3c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x3c, 0x00],
        '^' => [0x00, 0x18, 0x3c, 0x7e, 0x18, 0x18, 0x18, 0x18],
        '_' => [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff],
        '`' => [0x0c, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00],
        'a' => [0x00, 0x00, 0x3c, 0x06, 0x3e, 0x66, 0x3e, 0x00],
        'b' => [0x00, 0x60, 0x60, 0x7c, 0x66, 0x66, 0x7c, 0x00],
        'c' => [0x00, 0x00, 0x3c, 0x60, 0x60, 0x60, 0x3c, 0x00],
        'd' => [0x00, 0x06, 0x06, 0x3e, 0x66, 0x66, 0x3e, 0x00],
        'e' => [0x00, 0x00, 0x3c, 0x66, 0x7e, 0x60, 0x3c, 0x00],
        'f' => [0x00, 0x0e, 0x18, 0x3e, 0x18, 0x18, 0x18, 0x00],
        'g' => [0x00, 0x00, 0x3e, 0x66, 0x66, 0x3e, 0x06, 0x7c],
        'h' => [0x00, 0x60, 0x60, 0x7c, 0x66, 0x66, 0x66, 0x00],
        'i' => [0x00, 0x18, 0x00, 0x38, 0x18, 0x18, 0x3c, 0x00],
        'j' => [0x00, 0x06, 0x00, 0x06, 0x06, 0x06, 0x06, 0x3c],
        'k' => [0x00, 0x60, 0x60, 0x6c, 0x78, 0x6c, 0x66, 0x00],
        'l' => [0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x00],
        'm' => [0x00, 0x00, 0x66, 0x7f, 0x7f, 0x6b, 0x63, 0x00],
        'n' => [0x00, 0x00, 0x7c, 0x66, 0x66, 0x66, 0x66, 0x00],
        'o' => [0x00, 0x00, 0x3c, 0x66, 0x66, 0x66, 0x3c, 0x00],
        'p' => [0x00, 0x00, 0x7c, 0x66, 0x66, 0x7c, 0x60, 0x60],
        'q' => [0x00, 0x00, 0x3e, 0x66, 0x66, 0x3e, 0x06, 0x06],
        'r' => [0x00, 0x00, 0x7c, 0x66, 0x60, 0x60, 0x60, 0x00],
        's' => [0x00, 0x00, 0x3e, 0x60, 0x3c, 0x06, 0x7c, 0x00],
        't' => [0x00, 0x18, 0x7e, 0x18, 0x18, 0x18, 0x0e, 0x00],
        'u' => [0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x3e, 0x00],
        'v' => [0x00, 0x00, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x00],
        'w' => [0x00, 0x00, 0x63, 0x6b, 0x7f, 0x3e, 0x36, 0x00],
        'x' => [0x00, 0x00, 0x66, 0x3c, 0x18, 0x3c, 0x66, 0x00],
        'y' => [0x00, 0x00, 0x66, 0x66, 0x66, 0x3e, 0x0c, 0x78],
        'z' => [0x00, 0x00, 0x7e, 0x0c, 0x18, 0x30, 0x7e, 0x00],
        '{' => [0x0c, 0x18, 0x18, 0x30, 0x18, 0x18, 0x0c, 0x00],
        '|' => [0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00],
        '}' => [0x30, 0x18, 0x18, 0x0c, 0x18, 0x18, 0x30, 0x00],
        '~' => [0x31, 0x6b, 0x46, 0x00, 0x00, 0x00, 0x00, 0x00],
        _ => [0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff], // Block for unknown chars
    }
}

/// Global graphics context
lazy_static! {
    static ref GRAPHICS_CONTEXT: Mutex<Option<GraphicsContext>> = Mutex::new(None);
}

/// Initialize graphics subsystem
pub fn init() {
    println!("[graphics] Initializing graphics subsystem...");
    
    // Create default 1024x768 graphics context
    let ctx = GraphicsContext::new(1024, 768);
    *GRAPHICS_CONTEXT.lock() = Some(ctx);
    
    println!("[graphics] Graphics context created: 1024x768");
    println!("[graphics] Ready for rendering");
}

/// Get graphics context
pub fn context() -> Option<GraphicsContext> {
    GRAPHICS_CONTEXT.lock().clone()
}

/// Set graphics context
pub fn set_context(ctx: GraphicsContext) {
    *GRAPHICS_CONTEXT.lock() = Some(ctx);
}

/// Print graphics info
pub fn print_info() {
    if let Some(ref ctx) = *GRAPHICS_CONTEXT.lock() {
        println!("Graphics Information:");
        println!("  Resolution: {}x{}", ctx.width(), ctx.height());
        println!("  Buffer size: {} KB", ctx.pixels().len() * 4 / 1024);
    } else {
        println!("Graphics context not initialized");
    }
}

/// Integer square root (no_std compatible)
fn integer_sqrt(n: i32) -> i32 {
    if n <= 0 {
        return 0;
    }
    let n = n as u32;
    let mut x = n;
    let mut y = (x + 1) / 2;
    while y < x {
        x = y;
        y = (x + n / x) / 2;
    }
    x as i32
}

/// Color utilities
pub mod colors {
    /// RGB to u32 color
    pub const fn rgb(r: u8, g: u8, b: u8) -> u32 {
        0xFF000000 | ((b as u32) << 16) | ((g as u32) << 8) | (r as u32)
    }
    
    /// RGBA to u32 color
    pub const fn rgba(r: u8, g: u8, b: u8, a: u8) -> u32 {
        ((a as u32) << 24) | ((b as u32) << 16) | ((g as u32) << 8) | (r as u32)
    }
    
    pub const BLACK: u32 = 0xFF000000;
    pub const WHITE: u32 = 0xFFFFFFFF;
    pub const RED: u32 = 0xFF0000FF;
    pub const GREEN: u32 = 0xFF00FF00;
    pub const BLUE: u32 = 0xFFFF0000;
    pub const YELLOW: u32 = 0xFF00FFFF;
    pub const CYAN: u32 = 0xFFFFFF00;
    pub const MAGENTA: u32 = 0xFFFF00FF;
    pub const GRAY: u32 = 0xFF808080;
    pub const DARK_GRAY: u32 = 0xFF404040;
    pub const LIGHT_GRAY: u32 = 0xFFC0C0C0;
}

impl Clone for GraphicsContext {
    fn clone(&self) -> Self {
        Self {
            width: self.width,
            height: self.height,
            pixels: self.pixels.clone(),
        }
    }
}
